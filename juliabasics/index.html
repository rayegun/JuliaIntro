<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/JuliaIntro/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/JuliaIntro/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/JuliaIntro/css/franklin.css">
<link rel="stylesheet" href="/JuliaIntro/css/poole_hyde.css">
<link rel="stylesheet" href="/JuliaIntro/css/custom.css">
<link rel="stylesheet" href="/JuliaIntro/libs/highlight/styles/github-dark.min.css">

<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>

   <title>First Steps</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1><a href="/JuliaIntro/">QNumerics</a></h1>
      <div class="logo-container">
        <img src="/JuliaIntro/assets/qnumerics-logo.png" alt="QNumerics Logo" class="logo-img">
      </div>
    </div>
    <nav class="sidebar-nav">
      
      <a class="sidebar-nav-item " href="/JuliaIntro/">Home</a>			  
      <ul class="menu-list-child-list ">
        <li class="menu-list-item"><a href="/JuliaIntro/#goals" class="menu-list-link">Goals</a>
        <li class="menu-list-item"><a href="/JuliaIntro/#contents" class="menu-list-link">Contents</a>
        <li class="menu-list-item"><a href="/JuliaIntro/#before_you_start" class="menu-list-link">Before you start</a>
      </ul>
      
      <a class="sidebar-nav-item " href="/JuliaIntro/startup/">Setting Up Environment</a>
        <ul class="menu-list-child-list ">
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#git" class="menu-list-link">Git</a>
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#vscode" class="menu-list-link">Visual Studio Code</a>
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#julia_+_vscode" class="menu-list-link">Julia + VSCode</a>
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#tips_tricks" class="menu-list-link">Tips & Tricks</a>
        </ul>
      <a class="sidebar-nav-item active" href="/JuliaIntro/juliabasics/">First Steps</a>
        <ul class="menu-list-child-list active">
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#the_repl" class="menu-list-link">The REPL</a>
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#environments" class="menu-list-link">Environments</a>
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#package_management" class="menu-list-link">Package Management</a>
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#basic_syntax" class="menu-list-link">Basic Syntax</a>
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#arrays!" class="menu-list-link">Arrays!</a>
        </ul>
      <a class="sidebar-nav-item " href="/JuliaIntro/types/">Types</a>
        <ul class="menu-list-child-list ">
          <li class="menu-list-item"><a href="/JuliaIntro/types/#the_type_tree" class="menu-list-link">Type Trees</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#structs" class="menu-list-link">Structs</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#mutable_structs" class="menu-list-link">Mutable Structs</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#parametric_types" class="menu-list-link">Parametric Types</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#tuples" class="menu-list-link">Tuples</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#advanced_topics" class="menu-list-link">Advanced Topics</a>
        </ul>
      <a class="sidebar-nav-item " href="/JuliaIntro/dispatch/">Multiple Dispatch</a>
        <ul class="menu-list-child-list ">
          <li class="menu-list-item"><a href="/JuliaIntro/dispatch/#the_repl" class="menu-list-link">The REPL</a>
          <li class="menu-list-item"><a href="/JuliaIntro/dispatch/#package_management" class="menu-list-link">Package Management</a>
          <li class="menu-list-item"><a href="/JuliaIntro/dispatch/#basic_syntax" class="menu-list-link">Basic Syntax</a>
        </ul>
    </nav>
    <p class="copyright-notice">
      <a href="https://github.com/modernjuliaworkflows/modernjuliaworkflows.github.io/blob/main/LICENSE">
        &copy; Raye Skye Kimmerer.
      </a>
    </p>
    <div class="github-link">
      <a href="https://github.com/modernjuliaworkflows/modernjuliaworkflows.github.io">
        <svg xmlns="http://www.w3.org/2000/svg" height="28px" fill="currentColor" viewBox="0 0 496 512">
          
          <path
            d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z" />
        </svg>
      </a>
    </div>
  </div>
</div>
<div class="content container">


<script src="/JuliaIntro/libs/clipboard.min.js"></script>
<div class="franklin-content" >
  <h1 id="julia_first_steps" ><a href="#julia_first_steps"> Julia First Steps</a></h1><div class="toc"><ol><li><a href="#the_repl">The REPL</a></li><li><a href="#environments">Environments</a></li><li><a href="#package_management">Package Management</a></li><li><a href="#loading_packages">Loading packages</a></li><li><a href="#literals_and_variables">Literals and Variables</a></li><li><a href="#operators_and_functions">Operators and Functions</a></li><li><a href="#control_flow">Control Flow</a></li><li><a href="#a_note_on_scope">A note on scope</a></li><li><a href="#arrays!">Arrays!</a></li><li><a href="#tips_tricks_and_conventions">Tips Tricks and Conventions</a></li></ol></div><h2 id="the_repl" ><a href="#the_repl"> The REPL</a></h2><div class="tldr"><p><strong>TLDR</strong>: The Julia REPL has 4 modes: Julia, package (<code>]</code>), help (<code>?</code>) and shell (<code>;</code>). </p>
</div><p>The Read-Eval-Print Loop (or REPL) is the most basic way to interact with Julia, check out its <a href="https://docs.julialang.org/en/v1/stdlib/REPL/">documentation</a> for details.
You can start a REPL by typing <code>julia</code> into a terminal, or by clicking on the Julia application in your computer.
It will allow you to play around with arbitrary Julia code:</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> a, b = 1, 2;

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> a + b
3
</code></pre>
<p>This is the standard (Julia) mode of the REPL, but there are three other modes you need to know.
Each mode is entered by typing a specific character after the <code>julia&gt;</code> prompt.
Once you're in a non-Julia mode, you stay there for every command you run.
To exit it, hit backspace after the prompt and you'll get the <code>julia&gt;</code> prompt back.</p>
<h3 id="help_mode_(?)" ><a href="#help_mode_(?)"> Help mode (<code>?</code>)</a></h3><p>By pressing <code>?</code> you can obtain information and metadata about Julia objects (functions, types, etc.) or unicode symbols.
The query fetches the docstring of the object, which explains how to use it.</p>
<pre><code class="julia-repl"><span class="sgr33"><span class="sgr1">help?&gt;</span></span> println
</code></pre>
<div class="repl-help">
<pre><code>println&#40;&#91;io::IO&#93;, xs...&#41;</code></pre>
<p>Print &#40;using &#41; <code>xs</code> to <code>io</code> followed by a newline. If <code>io</code> is not supplied, prints to the default output stream .</p>
<p>See also  to add colors etc.</p>
<h1>Examples</h1>
<pre><code class="language-julia-repl">julia&gt; println&#40;&quot;Hello, world&quot;&#41;
Hello, world

julia&gt; io &#61; IOBuffer&#40;&#41;;

julia&gt; println&#40;io, &quot;Hello&quot;, &#39;,&#39;, &quot; world.&quot;&#41;

julia&gt; String&#40;take&#33;&#40;io&#41;&#41;
&quot;Hello, world.\n&quot;</code></pre>
</div>
<p>If you don't know the exact name you are looking for, type a word surrounded by quotes to see in which docstrings it pops up.</p>
<h3 id="package_mode_(])" ><a href="#package_mode_(])"> Package mode (<code>]</code>)</a></h3><p>By pressing <code>]</code> you access <a href="https://github.com/JuliaLang/Pkg.jl">Pkg.jl</a>, Julia's integrated package manager, whose <a href="https://pkgdocs.julialang.org/v1/getting-started/">documentation</a> is an absolute must-read.
Pkg.jl allows you to:</p>
<ul>
<li><code>]activate</code> different local, shared or temporary environments;</li>
<li><code>]instantiate</code> them by downloading the necessary packages;</li>
<li><code>]add</code>, <code>]update</code> (or <code>]up</code>) and <code>]remove</code> (or <code>]rm</code>) packages;</li>
<li>get the <code>]status</code> (or <code>]st</code>) of your current environment.</li>
</ul>
<p>As an illustration, we download the package Example.jl inside our current environment:</p>
<pre><code class="julia-repl"><span class="sgr34"><span class="sgr1">(JuliaIntro) pkg&gt;</span></span> add Example
<span class="sgr33"><span class="sgr1">┌ Warning: </span></span>The Pkg REPL mode is intended for interactive use only, and should not be used from scripts. It is recommended to use the functional API instead.
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ Pkg.REPLMode /opt/hostedtoolcache/julia/1.11.6/x64/share/julia/stdlib/v1.11/Pkg/src/REPLMode/REPLMode.jl:388</span>
<span class="sgr32"><span class="sgr1">   Resolving</span></span> package versions...
<span class="sgr32"><span class="sgr1">   Installed</span></span> Example ─ v0.5.5
<span class="sgr32"><span class="sgr1">    Updating</span></span> `~/work/JuliaIntro/JuliaIntro/Project.toml`
  <span class="sgr90">[7876af07] </span><span class="sgr92">+ Example v0.5.5</span>
<span class="sgr32"><span class="sgr1">    Updating</span></span> `~/work/JuliaIntro/JuliaIntro/Manifest.toml`
  <span class="sgr90">[7876af07] </span><span class="sgr92">+ Example v0.5.5</span>
Precompiling project...
    426.7 ms  ✓ Example
  1 dependency successfully precompiled in 1 seconds. 303 already precompiled.
</code></pre>
<pre><code class="julia-repl"><span class="sgr34"><span class="sgr1">(JuliaIntro) pkg&gt;</span></span> status
<span class="sgr32"><span class="sgr1">Status</span></span> `~/work/JuliaIntro/JuliaIntro/Project.toml`
  <span class="sgr90">[1520ce14] </span>AbstractTrees v0.4.5
  <span class="sgr90">[6e4b80f9] </span>BenchmarkTools v1.6.0
  <span class="sgr90">[13f3f980] </span>CairoMakie v0.15.3
  <span class="sgr90">[7876af07] </span>Example v0.5.5
  <span class="sgr90">[cd3eb016] </span>HTTP v1.10.17
  <span class="sgr90">[98b081ad] </span>Literate v2.20.1
  <span class="sgr90">[2bd173c7] </span>NodeJS v2.0.0
  <span class="sgr90">[c3e4b0f8] </span>Pluto v0.20.13
  <span class="sgr90">[b77e0a4c] </span>InteractiveUtils v1.11.0
  <span class="sgr90">[37e2e46d] </span>LinearAlgebra v1.11.0
</code></pre>
<p>Note that the same keywords are also available in Julia mode:</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> using Pkg

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Pkg.rm(&quot;Example&quot;)
<span class="sgr32"><span class="sgr1">    Updating</span></span> `~/work/JuliaIntro/JuliaIntro/Project.toml`
  <span class="sgr90">[7876af07] </span><span class="sgr91">- Example v0.5.5</span>
<span class="sgr32"><span class="sgr1">    Updating</span></span> `~/work/JuliaIntro/JuliaIntro/Manifest.toml`
  <span class="sgr90">[7876af07] </span><span class="sgr91">- Example v0.5.5</span>
<span class="sgr36"><span class="sgr1">        Info</span></span> We haven&#39;t cleaned this depot up for a bit, running Pkg.gc()...
<span class="sgr32"><span class="sgr1">      Active</span></span> manifest files: 2 found
<span class="sgr32"><span class="sgr1">      Active</span></span> artifact files: 60 found
<span class="sgr32"><span class="sgr1">      Active</span></span> scratchspaces: 1 found
<span class="sgr32"><span class="sgr1">     Deleted</span></span> no artifacts, repos, packages or scratchspaces
</code></pre>
<p>The package mode itself also has a help mode, accessed with <code>?</code>, in case you're lost among all these new keywords.</p>
<h3 id="shell_mode_(;)" ><a href="#shell_mode_(;)"> Shell mode (<code>;</code>)</a></h3><p>By pressing <code>;</code> you enter a terminal, where you can execute any command you want.
Here's an example for Unix systems:</p>
<h2 id="environments" ><a href="#environments"> Environments</a></h2><div class="tldr"><p><strong>TLDR</strong>: Activate a local environment for each project with <code>]activate path</code>. Its details are stored in <code>Project.toml</code> and <code>Manifest.toml</code>. </p>
</div><p>As we have seen, Pkg.jl is the Julia equivalent of <code>pip</code> or <code>conda</code> for Python.
It lets you <a href="https://pkgdocs.julialang.org/v1/managing-packages/">install packages</a> and <a href="https://pkgdocs.julialang.org/v1/environments/">manage environments</a> (collections of packages with specific versions).</p>
<p>You can activate an environment from the Pkg REPL by specifying its path <code>]activate somepath</code>.
Typically, you would do <code>]activate .</code> to activate the environment in the current directory.
Another option is to directly start Julia inside an environment, with the command line option <code>julia --project=somepath</code>.</p>
<p>Once in an environment, the packages you <code>]add</code> will be listed in two files <code>somepath/Project.toml</code> and <code>somepath/Manifest.toml</code>:</p>
<ul>
<li><code>Project.toml</code> contains general project information (name of the package, unique id, authors) and direct dependencies with version bounds.</li>
<li><code>Manifest.toml</code> contains the exact versions of all direct and indirect dependencies</li>
</ul>
<p>If you haven't entered any local project, packages will be installed in the default environment, called <code>@v1.X</code> after the active version of Julia (note the <code>@</code> before the name).
Packages installed that way are available no matter which local environment is active, because of "environment <a href="https://docs.julialang.org/en/v1/manual/code-loading/#Environment-stacks">stacking</a>".
It is recommended to keep the default environment very light to avoid dependencies conflicts. It should contain only essential development tools.</p>
<div class="vscode"><p><strong>VSCode</strong>: You can configure the <a href="https://www.julia-vscode.org/docs/stable/userguide/env/">environment</a> in which a VSCode Julia REPL opens.
 Just click the <code>Julia env: ...</code> button at the bottom.
 Note however that the Julia version itself will always be the default one from <code>juliaup</code>.</p>
</div><div class="advanced"><p><strong>Advanced</strong>: You can visualize the dependency graph of an environment with <a href="https://github.com/peng1999/PkgDependency.jl">PkgDependency.jl</a>.</p>
</div><h2 id="package_management" ><a href="#package_management"> Package Management</a></h2><p>We're going to explore how package management and code structure typically works using <a href="https://github.com/giordano/StarWarsArrays.jl">this repository</a></p>
<h1 id="basic_syntax" ><a href="#basic_syntax"> Basic Syntax</a></h1><p>Julia has a fairly simple syntax which is:</p>
<ol>
<li>"Close to the math" so that code resembles the equivalent algorithm in plain math or pseudocode. Unicode symbols can help get even closer to math notation.</li>
<li>Avoids too much unique syntax / keywords in favor of macros</li>
<li>Familiar (enough) to users of MATLAB or Python</li>
</ol>
<div class="important"><p><strong>Important</strong> - <strong>Everything in Julia is an <em>expression</em>:</strong>
(Almost) every piece of syntax in Julia is an <em><strong>expression</em></strong>. That means that is has an associated <em><strong>value</em></strong>. For instance the expression <code>2 + 2</code> has the value <code>4</code>.
<br>

Keep this in mind as we go through the code.</p>
</div><h2 id="loading_packages" ><a href="#loading_packages"> Loading packages</a></h2><p>Before we get into basic syntax we will need a few packages for this tutorial.
While you can load packages at any top-level scope, it's best practice to do so at the beginning of your file, package, or notebook.</p>
<pre><code class="julia">using LinearAlgebra, Random, CairoMakie # for plotting</code></pre>
<h2 id="literals_and_variables" ><a href="#literals_and_variables"> Literals and Variables</a></h2><p>A literal is a representation of some data directly in code. For instance:</p>
<pre><code class="julia">4</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">4</code></pre></div><p>is the literal for the 64-bit Integer number \(4\).
<br>

<strong>Note:</strong> Since this is an expression is has a value of 4.
Notebooks and the REPL will automatically print out the value of an expression (or the last expression in a code block), <em>unless</em> the value of an expression is the special constant:</p>
<pre><code class="julia">nothing</code></pre>
<p>The other way to suppress the output of an expression is to use <code>;</code> character which can also be used to delimit multiple statements on a single line.</p>
<pre><code class="julia">5; 6; 7;</code></pre>
<p>Other literals include:</p>
<pre><code class="julia">&quot;Howdy folks!&quot;; # string
3.14159265     # floating point (Float64)
true           # Boolean
[1, 2, 3, 4]   # Vector of Int64</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">4-element Vector{Int64}:
 1
 2
 3
 4</code></pre></div><pre><code class="julia">(1, 3.14159, &quot;Quantum? Never met 'em!&quot;) # A Tuple (an immutable fixed length collection)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">(1, 3.14159, "Quantum? Never met 'em!")</code></pre></div><p>A symbol is an identifier, a set of characters prefixed by a colon.
Mostly used internally for Julia, they are essentially how you represent names (variables) as data.
They are a little different than strings, but you won't see them often.</p>
<pre><code class="julia">:iamasymbol
:🐱</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">:🐱</code></pre></div><p>Now that we have literals we might like to give them a name.
We can assign literals (and any other data) to a variable, which is simply a named value:</p>
<pre><code class="julia">a = [1,2,3,4]
w = 10
y = true</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">true</code></pre></div><p>We can interpolate into strings by either <code>$y</code> or <code>$(w + 2)</code> for more complex expressions</p>
<pre><code class="julia">x = &quot;Are are at UMass Amherst? $y&quot;</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">"Are are at UMass Amherst? true"</code></pre></div><p>Assignments are an expression whose value is the right-hand-side.
This lets us, among other things, chain assignments:</p>
<pre><code class="julia">i = j = 5; # both i and j are equal to 5
@show i j</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">i = 5
j = 5
</code></pre></div><p>Variables are not constrained to a particular type.</p>
<pre><code class="julia">x = 13.5 # reassign x to a different type.</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">13.5</code></pre></div><p>Julia has support for Unicode variable names.
In VSCode and the REPL we can use autocompletion such as <code>\Sigma</code>-TAB-<code>\hat</code>-TAB-<code>\^2</code>-TAB</p>
<pre><code class="julia">Σ̂² = 1.0;</code></pre>
<p>There is complete support for all of Unicode, so that means we have emoji as well!</p>
<pre><code class="julia">😳 = 5 # `\:flushed`-TAB
⚛️ = &quot;Quantum Numerics!&quot; # I don't think this has an autocomplete yet 🤔</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">"Quantum Numerics!"</code></pre></div><p>Julia allows for <em>numeric</em> literals to be <strong>immediately</strong> followed by a variable, which results in multiplication:</p>
<pre><code class="julia">3x</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">40.5</code></pre></div><p>This helps us write long equations very nicely:</p>
<pre><code class="julia">4(x + 3)^2 - 10</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">1079.0</code></pre></div><p>This functionality is also used for complex number literals, with the global constant <code>im</code>:</p>
<pre><code class="julia">10 + 3im</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">10 + 3im</code></pre></div><h2 id="operators_and_functions" ><a href="#operators_and_functions"> Operators and Functions</a></h2><p>Like most languages Julia has two syntaxes for operating on values: operators and function calls.</p>
<h3 id="operators" ><a href="#operators"> Operators</a></h3><pre><code class="julia">w + x + Σ̂²</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">24.5</code></pre></div><pre><code class="julia">2 ^ 5 # exponentiation</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">32</code></pre></div><p>There are also Unicode operators, for instance this is integer division:</p>
<pre><code class="julia">5 ÷ 2 # (`5 \div`-TAB-`2`)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">2</code></pre></div><pre><code class="julia">∛8 # `\cbrt`-TAB-`8`</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">2.0</code></pre></div><p>The boolean operators are:</p>
<pre><code class="julia">!y # negation
false &amp;&amp; y # short circuiting and
y || true # short circuiting or</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">true</code></pre></div><p>The <code>&lt;op&gt;=</code> operators update a variable, such as:</p>
<pre><code class="julia">w += 3</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">13</code></pre></div><h3 id="functions" ><a href="#functions"> Functions</a></h3><p>Functions are called much as they are in other languages like Python:</p>
<pre><code class="julia">sin(2x)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">0.956375928404503</code></pre></div><pre><code class="julia">length(a)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">4</code></pre></div><pre><code class="julia">complex(1.0, 10)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">1.0 + 10.0im</code></pre></div><p>There are three syntaxes for defining functions. The first two produce named functions, and we'll get to the third in a moment.
The general form is:</p>
<pre><code class="julia">function foo(x, y)
    # we don't actually need the `return` here
    # the last expression is returned by default
    return x + y
end</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">foo (generic function with 1 method)</code></pre></div><p>and the terse form which is typically used if your function is a single expression:</p>
<pre><code class="julia">bar(x, y) = x + y</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">bar (generic function with 1 method)</code></pre></div><p>We can call this function as above:</p>
<pre><code class="julia">@show foo(w, x) == bar(w, x)</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">foo(w, x) == bar(w, x) = true
</code></pre></div><h4 id="keyword_and_optional_arguments" ><a href="#keyword_and_optional_arguments"> Keyword and optional arguments</a></h4><p>We can add "keyword" arguments to a function by placing them after a semicolon in the arguments:</p>
<pre><code class="julia">function mykwargs(a; b)
    a ^ b
end;</code></pre>
<p>Both positional arguments and keyword arguments can be made optional by providing a default value.
Ignore the <code>@show</code> for now we'll get to that later, it prints out the expression and its result.</p>
<pre><code class="julia">function myoptionalfunc(a = 2; b = 3)
    a ^ b
end
@show myoptionalfunc()
@show myoptionalfunc(b = 3)
@show myoptionalfunc(5)
@show myoptionalfunc(5, b = 2)</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">myoptionalfunc() = 8
myoptionalfunc(b = 3) = 8
myoptionalfunc(5) = 125
myoptionalfunc(5, b = 2) = 25
</code></pre></div><p>Operators are "just" functions with support for infix notation (except <code>&amp;&amp;</code> and <code>||</code> which uniquely short circuit)</p>
<pre><code class="julia">+(1, 2, 3, 4)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">10</code></pre></div><pre><code class="julia">f = *
f(1, 2, 3)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">6</code></pre></div><h4 id="functions_are_data" ><a href="#functions_are_data"> Functions are data</a></h4><p>Just like strings or vectors and can be assigned to variables:</p>
<pre><code class="julia">baz = foo
baz(w, x)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">26.5</code></pre></div><p>They can also be passed to other functions:</p>
<pre><code class="julia">map(sin, [1.0, 2.0, π])</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Float64}:
 0.8414709848078965
 0.9092974268256817
 1.2246467991473532e-16</code></pre></div><h4 id="anonymous_functions" ><a href="#anonymous_functions"> Anonymous functions</a></h4><p>The third syntax for defining a function is for so-called anonymous functions (functions without a name)</p>
<pre><code class="julia">x -&gt; 5x + (x - 1)^2</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">#3 (generic function with 1 method)</code></pre></div><p>Of course we didn't give it a name, so now we have no way to reference it!
These are most often used to pass to "higher-order" functions (functions that accept other functions as arguments):</p>
<pre><code class="julia">map(x -&gt; 5x + (x - 1)^2, a)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">4-element Vector{Int64}:
  5
 11
 19
 29</code></pre></div><p>For anonymous functions with multiple arguments the syntax looks like this:</p>
<pre><code class="julia">(x, y, z) -&gt; x/3 + y^3 + z^2</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">#7 (generic function with 1 method)</code></pre></div><p>or with zero arguments like this:</p>
<pre><code class="julia">() -&gt; 2 + 2</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">#9 (generic function with 1 method)</code></pre></div><h3 id="broadcasting" ><a href="#broadcasting"> Broadcasting</a></h3><p>We often encounter situations where we want to call a function such as <code>sin</code>
over all elements of a collection like a <code>Vector</code>.
In order to make this ergonomic Julia supports a generalized "broadcasting" syntax:</p>
<pre><code class="julia">sin.([1, 2, 3])</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Float64}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672</code></pre></div><p>Any function can be suffixed with a <code>.</code> in order to broadcast it elementwise over each value in a collection.
This also works elementwise, for instance:</p>
<pre><code class="julia">complex.([1, 2, 3], [10, 20, 30])</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Complex{Int64}}:
 1 + 10im
 2 + 20im
 3 + 30im</code></pre></div><p>or with operators in infix form:</p>
<pre><code class="julia">[1, 2, 3] .+ [4, 5, 6]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Int64}:
 5
 7
 9</code></pre></div><h2 id="control_flow" ><a href="#control_flow"> Control Flow</a></h2><p>We now know how to define variables, call functions and operators, and define basic functions.
For a bit of a break let's look at the following function which computes a single point in the mandelbrot set to get a sense for control flow:</p>
<pre><code class="julia">function mandel(z)
	c = z
	maxiter = 80
	for n in 1:maxiter
	  if abs(z) &gt; 2
		  return n-1
	  end
	  z = z^2 + c
	end
	return maxiter
end;</code></pre>
<p>We need a complex plane to compute the set on:</p>
<pre><code class="julia">resolution = 0.02
reals = -2:resolution:1 # range from -2 to 1 with step size of 0.02
imgs = -1:resolution:1
plane = [complex(re, img) for (re, img) in Iterators.product(reals, imgs)];
results = mandel.(plane);</code></pre>
<p>We're going to use a package called CairoMakie to plot the result:</p>
<pre><code class="julia">CairoMakie.heatmap(results)</code></pre>
<div class="code-output"><img class="code-figure" src="/JuliaIntro/assets/juliabasics/index/figs-html/__autofig_2322465883030802333.svg">
</div><p>Let's break down some of the expressions we saw above:</p>
<h3 id="conditionals" ><a href="#conditionals"> Conditionals</a></h3><p>We have a conditional block above which tests whether <code>abs(z) &gt; 2</code>.
A general control flow block looks something like:</p>
<pre><code class="julia">x = 5; y = 10; z = true
if x &lt; y
    println(&quot;Small x!&quot;)
elseif x == y
    println(&quot;x and y are equal!&quot;)
else
    println(&quot;Big x!&quot;)
end</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">Small x!
</code></pre></div><p>Many languages have a ternary expression, for a short way to evaluate a two way conditional:</p>
<pre><code class="julia">println(x &lt; y ? &quot;x is less than y!&quot; : &quot;x is greater than or equal to y!&quot;)</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">x is less than y!
</code></pre></div><p>Julia users really like to keep code compact, so there is one additional conditional expression you might see:</p>
<pre><code class="julia">x &lt; y &amp;&amp; println(&quot;x was less than y!&quot;)

x &lt; y || println(&quot;I don't get here if x &lt; y!&quot;)</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">x was less than y!
</code></pre><pre><code class="code-result language-plaintext">true</code></pre></div><p>It's important to note that conditional expressions (like <code>if-elseif-else</code>) are <em>short-circuiting</em>.
This means that in the expression:</p>
<pre><code class="julia">a &amp;&amp; b</code></pre>
<p><code>b</code> is only evaluated if <code>a</code> is <code>true</code>!
Similarly in</p>
<pre><code class="julia">a || b</code></pre>
<p><code>b</code> will only be evaluated if <code>a = false</code></p>
<h3 id="loops" ><a href="#loops"> Loops</a></h3><p>Our <code>mandelbrot</code> function also has a <code>for</code> loop iterating over the range <code>1:maxiter</code>.</p>
<p>There are two loop constructs in Julia. <code>while</code> loops:</p>
<pre><code class="julia">i = 1;
while i &lt;= 5
    println(&quot;i = $i&quot;)
    i += 1
end</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">i = 1
i = 2
i = 3
i = 4
i = 5
</code></pre></div><p>and <code>for</code> loops (note that <code>i</code> is local to the <code>for</code> loop block, unlike with the <code>while</code> above):</p>
<pre><code class="julia">for i in 1:2:9
    println(&quot;i = $i&quot;)
end</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">i = 1
i = 3
i = 5
i = 7
i = 9
</code></pre></div><p><code>for</code> loops can iterate over many different containers, including the <code>Vector</code>s, <code>Tuple</code>s,
<code>StepRange</code>s like <code>1:2:9</code>, <code>UnitRange</code>s like <code>1:10</code> and more.</p>
<p>Instead of the <code>in</code> keyword we can also use <code>=</code> and <code>∈</code> (<code>\in</code>-TAB).</p>
<p>When we are looping over containers like <code>Vector</code>s it's important to be sure we know what we are looping over!
We will get to indexing when we talk about arrays in the next section, but for now we can index a <code>Vector</code> as follows:</p>
<pre><code class="julia">emojis = [&quot;🤔&quot;, &quot;⚛️&quot;, &quot;💻&quot;];
@show emojis[1]
@show emojis[3]</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">emojis[1] = &quot;🤔&quot;
emojis[3] = &quot;💻&quot;
</code></pre></div><p>Notice that Julia is (<strong>generally</strong>) 1-based, <strong>not</strong> 0 based!</p>
<pre><code class="julia">println(&quot;Iterating over each value:&quot;)
for i ∈ emojis
    println(i)
end

println(&quot;Iterating over the indices:&quot;)
for i ∈ 1:length(emojis)
    println(i)
end

println(&quot;Iterating over the indices but printing value:&quot;)
for i ∈ eachindex(emojis)
    println(emojis[i])
end</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">Iterating over each value:
🤔
⚛️
💻
Iterating over the indices:
1
2
3
Iterating over the indices but printing value:
🤔
⚛️
💻
</code></pre></div><p>Notice that we switched to using <code>eachindex</code> instead of <code>length</code>. Can you guess why?</p>
<h4 id="break_and_continue" ><a href="#break_and_continue"> <code>break</code> and <code>continue</code></a></h4><p>If you need to stop a loop early the <code>break</code> keyword will immediately terminate a loop.
If you need to skip an iteration the <code>continue</code> keyword will immediately start the next iteration of the loop.</p>
<pre><code class="julia">for i ∈ emojis
    i == &quot;⚛️&quot; &amp;&amp; continue
    println(i)
end</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">🤔
💻
</code></pre></div><p>That covers most of the basic syntax we will need to get started. </p>
<h2 id="a_note_on_scope" ><a href="#a_note_on_scope"> A note on scope</a></h2><p>Variables or names are part of a scope:</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> x = 5
5

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> foo(y, z) = x + y + z # x is available from global scope
Main.__FRANKLIN_1309937.foo

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> foo(10, 20)
35

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> bar(x, y) = x - y # x is &quot;shadowed&quot; by the argument
Main.__FRANKLIN_1309937.bar

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> bar(10, 3)
7
</code></pre>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> module Mod
    x, y, z = (1, 2, 3)
    foo(z) = println(x, y, z)
end
Main.__FRANKLIN_1309937.Mod

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> import .Mod

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> x = 50
50

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Mod.foo(10)
1210
</code></pre>
<h2 id="arrays!" ><a href="#arrays!"> Arrays!</a></h2><p>Forgive the section title 😇</p>
<p>Julia has a fantastic built-in standard library for linear algebra.</p>
<pre><code class="julia">using LinearAlgebra</code></pre>
<h3 id="what_is_an_"array"_in_julia?" ><a href="#what_is_an_"array"_in_julia?"> What is an "Array" in Julia?</a></h3><p>Many languages have different concepts of arrays.
In a language like C you might use raw pointers 😱.
<br>

In a language like Python you might use NumPy arrays or PyTorch tensors</p>
<blockquote><p><strong>Types</strong></p>
<p>This section will start talking a bit about types.
If it's a bit confusing don't worry, the next section will clear up any confusion!</p>
</blockquote><p>In Julia the array types stick pretty close to the mathematical sense of the word.
The most common three array types in Julia are:</p>
<pre><code class="julia">Vector&lbrace;T&rbrace; where T</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">Vector (alias for Array{T, 1} where T)</code></pre></div><pre><code class="julia">Matrix&lbrace;T&rbrace; where T</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">Matrix (alias for Array{T, 2} where T)</code></pre></div><pre><code class="julia">Array&lbrace;T, N&rbrace; where &lbrace;T, N&rbrace;;</code></pre>
<p>If this syntax is confusing to you don't worry! We'll talk more about this later but the expressions above are <em><strong>types</em></strong>. Specifically they are <em><strong>parametric types</em></strong> with a placeholder <code>T</code> for the element type. The <code>N</code> parameter for array is the dimension, which is an integer!</p>
<p>We can substitute different things such as types for the placeholder <code>T</code>, for instance:</p>
<pre><code class="julia">Vector&lbrace;Int64&rbrace;</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">Vector{Int64} (alias for Array{Int64, 1})</code></pre></div><p>is a <code>Vector</code> with 64-bit integer elements.</p>
<p>If we go a bit further we can create high dimensional array types:</p>
<pre><code class="julia">Array&lbrace;Bool, 6&rbrace;</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">Array{Bool, 6}</code></pre></div><p>Notice that <code>Vector</code> and <code>Matrix</code> are simply aliases for the a 1 dimensional and 2 dimensional <code>Array</code> respectively</p>
<h3 id="constructing_arrays" ><a href="#constructing_arrays"> Constructing arrays</a></h3><p>We've already seen literals several times!</p>
<pre><code class="julia">[1,2,3]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Int64}:
 1
 2
 3</code></pre></div><p>Here's some new literals!</p>
<pre><code class="julia">[&quot;🐞&quot; &quot;🐕&quot;
 &quot;🐻&quot; &quot;🧚&quot;]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">2×2 Matrix{String}:
 "🐞"  "🐕"
 "🐻"  "🧚"</code></pre></div><pre><code class="julia">A = [1 2; 3 4]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">2×2 Matrix{Int64}:
 1  2
 3  4</code></pre></div><p>There are <em>lots</em> of ways to write array literals in Julia. Check out your cheatsheet for more.</p>
<h4 id="comprehensions" ><a href="#comprehensions"> Comprehensions</a></h4><p>We have a funky syntax for constructing called <em>comprehensions</em>:</p>
<pre><code class="julia">[x for x in 1:10 if x % 3 == 1]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">4-element Vector{Int64}:
  1
  4
  7
 10</code></pre></div><pre><code class="julia">[i + j for i in 1:4, j in 1:3]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">4×3 Matrix{Int64}:
 2  3  4
 3  4  5
 4  5  6
 5  6  7</code></pre></div><h4 id="constructors" ><a href="#constructors"> Constructors</a></h4><p>Every type in Julia has constructors, which are functions that return a specific type
We have constructors for basic numeric types and strings:</p>
<pre><code class="julia">Float64(10)
String(&quot;asdf&quot;)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">"asdf"</code></pre></div><p>The most basic array constructors:</p>
<pre><code class="julia">Vector&lbrace;Int64&rbrace;(undef, 5) # 5 element Vector</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">5-element Vector{Int64}:
 140694702428304
 140694702428304
               0
               0
    413720328211</code></pre></div><pre><code class="julia">Matrix&lbrace;Float32&rbrace;(undef, 2, 3)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">2×3 Matrix{Float32}:
 9.87156f34  1.06094f28  1.06094f28
 4.5904f-41  4.5904f-41  4.5904f-41</code></pre></div><p>Notice that the values are random. The <code>undef</code> constructors, which use the special <code>undef</code> global constant contain uninitialized memory whose values haven't been set to zero.</p>
<p>There is also special juxtaposition syntax for empty arrays:</p>
<pre><code class="julia">Float32[]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">Float32[]</code></pre></div><h4 id="functions_that_generate_arrays" ><a href="#functions_that_generate_arrays"> Functions that generate arrays:</a></h4><pre><code class="julia">zeros(Bool, 3)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Bool}:
 0
 0
 0</code></pre></div><pre><code class="julia">zeros(5, 5)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">5×5 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0</code></pre></div><pre><code class="julia">fill(1 + 10im, 2, 2)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">2×2 Matrix{Complex{Int64}}:
 1+10im  1+10im
 1+10im  1+10im</code></pre></div><pre><code class="julia">rand(Int8)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">44</code></pre></div><pre><code class="julia">rand(5)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">5-element Vector{Float64}:
 0.3200839935918641
 0.8259454801724266
 0.3899262423436698
 0.2937366408666776
 0.5357347290287493</code></pre></div><pre><code class="julia">rand([:🐱, :🐶, :🐦, :🐴])</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">:🐴</code></pre></div><p>You can see above how we have used the <code>rand</code> function for 3 completely different tasks above. We will talk more about this with <code>methods</code> later.</p>
<h3 id="indexing" ><a href="#indexing"> Indexing</a></h3><pre><code class="julia">v = collect(1:2:9)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">5-element Vector{Int64}:
 1
 3
 5
 7
 9</code></pre></div><pre><code class="julia">v[4] # 1-based indexing!</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">7</code></pre></div><pre><code class="julia">M = [1 2 3
     4 5 6
     7 8 9]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3×3 Matrix{Int64}:
 1  2  3
 4  5  6
 7  8  9</code></pre></div><p>We can still index <code>M</code> with a single integer:</p>
<pre><code class="julia">M[5]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">5</code></pre></div><p>Can you guess what is happening above? This is called <em>linear indexing</em></p>
<pre><code class="julia">M[2, 3] # &quot;cartesian&quot; indexing</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">6</code></pre></div><h3 id="slicing" ><a href="#slicing"> Slicing</a></h3><pre><code class="julia">M[:, 1]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Int64}:
 1
 4
 7</code></pre></div><pre><code class="julia">M[2, :]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Int64}:
 4
 5
 6</code></pre></div><p>The <code>:</code> is a placeholder for the entire range of the specified dimension</p>
<h3 id="fancy_indexing" ><a href="#fancy_indexing"> Fancy indexing</a></h3><pre><code class="julia">M[[1, 3, 6]]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Int64}:
 1
 7
 8</code></pre></div><pre><code class="julia">bools = rand(Bool, length(v))</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">5-element Vector{Bool}:
 1
 0
 1
 1
 1</code></pre></div><pre><code class="julia">v[bools]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">4-element Vector{Int64}:
 1
 5
 7
 9</code></pre></div><p>We can use the boolean version of indexing and the broadcasting we discussed earlier to filter!</p>
<pre><code class="julia">v = rand(1:10, 8)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">8-element Vector{Int64}:
  9
  1
  6
 10
  4
  2
  6
  8</code></pre></div><pre><code class="julia">v[v .&gt; 5]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">5-element Vector{Int64}:
  9
  6
 10
  6
  8</code></pre></div><h3 id="setting_values" ><a href="#setting_values"> Setting values</a></h3><p>Getting values from an array is very similar to setting them:</p>
<pre><code class="julia">M[2, 2] = 10</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">10</code></pre></div><p>But wait!!! Why is the value of the expression the RHS?
We can see that <code>M</code> has been modified:</p>
<pre><code class="julia">M</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3×3 Matrix{Int64}:
 1   2  3
 4  10  6
 7   8  9</code></pre></div><p>We can use all the same fancy indexing with a catch, if we refer to multiple indices on the left hand side we must use broadcasting!</p>
<pre><code class="julia">M[:, 1] .= 2M[:, begin]</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element view(::Matrix{Int64}, :, 1) with eltype Int64:
  2
  8
 14</code></pre></div><pre><code class="julia">M</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3×3 Matrix{Int64}:
  2   2  3
  8  10  6
 14   8  9</code></pre></div><p>We can use the <code>begin</code> and <code>end</code> keywords instead of the 1st index (which might <em>not</em> be 1 😈) and the last index in a dimension.</p>
<p>We get off easy with the broadcasting above since the shapes of the left hand side and right hand side obviously matched. What if they didn't?</p>
<pre><code class="julia">M[1, 1:2] .= [1,2,3]</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">ERROR: DimensionMismatch: array could not be broadcast to match destination
Stacktrace:
  [1] check_broadcast_shape
    @ ./broadcast.jl:552 [inlined]
  [2] check_broadcast_axes
    @ ./broadcast.jl:555 [inlined]
  [3] instantiate
    @ ./broadcast.jl:310 [inlined]
  [4] materialize!
    @ ./broadcast.jl:883 [inlined]
  [5] materialize!(dest::SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, UnitRange{Int64}}, true}, bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(identity), Tuple{Vector{Int64}}})
    @ Base.Broadcast ./broadcast.jl:880
</code></pre></div><p>💥💥💥💥!</p>
<h3 id="a_few_important_functions_that_on_arrays" ><a href="#a_few_important_functions_that_on_arrays"> A few important functions that on Arrays</a></h3><pre><code class="julia">size(M)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">(3, 3)</code></pre></div><pre><code class="julia">@show length(M) == size(M, 1) * size(M, 2)</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">length(M) == size(M, 1) * size(M, 2) = true
</code></pre></div><p>Reshape a 6 element range into a matrix, then flatten it into a vector</p>
<pre><code class="julia">vec(reshape(collect(1:6), 2, 3))</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre></div><p>What happens if we take away the collect?</p>
<pre><code class="julia">vec(reshape(1:6, 2, 3)) # we'll talk about this kind of trick later</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">1:6</code></pre></div><p>Concatenating arrays is an important but tricky operation</p>
<pre><code class="julia">vcat([1, 2, 3], [4, 5, 6])</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre></div><pre><code class="julia">hcat([1,2,3], [4,5,6])</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3×2 Matrix{Int64}:
 1  4
 2  5
 3  6</code></pre></div><p>We can do more than just set specific indices of arrays (well, at least Vectors).
Julia's <code>Vector</code> type can grow and shrink:</p>
<pre><code class="julia">v = [] # Notice the type of `v`</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">Any[]</code></pre></div><pre><code class="julia">push!(v, :🧡)
push!(v, :🚙)
pushfirst!(v, :💙)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Any}:
 :💙
 :🧡
 :🚙</code></pre></div><p>We've got a new convention to examine! In the Julia universe by convention (but not enforced by the compiler), functions which mutate one or more argument have <code>!</code> as a suffix.</p>
<pre><code class="julia">v</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">3-element Vector{Any}:
 :💙
 :🧡
 :🚙</code></pre></div><pre><code class="julia">pop!(v)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">:🚙</code></pre></div><pre><code class="julia">v</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">2-element Vector{Any}:
 :💙
 :🧡</code></pre></div><h1 id="a_bit_of_fun" ><a href="#a_bit_of_fun"> A bit of fun</a></h1><h2 id="tips_tricks_and_conventions" ><a href="#tips_tricks_and_conventions"> Tips Tricks and Conventions</a></h2><h3 id="can't_figure_out_how_to_type_a_unicode_character?" ><a href="#can't_figure_out_how_to_type_a_unicode_character?"> Can't figure out how to type a Unicode character?</a></h3><p>We will be using lots of Unicode characters throughout the week. If you can't figure out how to type a character, but you're able to copy and paste it into the REPL you can use the <code>help</code> REPL we discussed earlier:</p>
<pre><code class="julia">help?&gt; 🤔</code></pre>
<h3 id="13633231208144796923" ><a href="#13633231208144796923"> </a></h3>
  <div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Raye Skye Kimmerer. Last modified: July 14, 2025. </br>
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>

</div>

    </div>  
    
        <script src="/JuliaIntro/libs/katex/katex.min.js"></script>
<script src="/JuliaIntro/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/JuliaIntro/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>


<script>
(function(){

	// Get the elements.
	// - the 'pre' element.
	// - the 'div' with the 'paste-content' id.

	var pre = document.getElementsByTagName('pre');

	// Add a copy button in the 'pre' element.
	// which only has the className of 'language-' or ' hljs'(if enable highlight.js pre-render).

	for (var i = 0; i < pre.length; i++) {
		var tag_name = pre[i].children[0].className
            	var isLanguage = tag_name.startsWith('language-') || tag_name.endsWith(' hljs');
		if ( isLanguage ) {
			var button           = document.createElement('button');
					button.className = 'copy-button';
					button.textContent = 'Copy';

					pre[i].appendChild(button);
		}
	};

	// Run Clipboard

	var copyCode = new Clipboard('.copy-button', {
		target: function(trigger) {
			return trigger.previousElementSibling;
    }
	});

	// On success:
	// - Change the "Copy" text to "Copied".
	// - Swap it to "Copy" in 2s.
	// - Lead user to the "contenteditable" area with Velocity scroll.

	copyCode.on('success', function(event) {
		event.clearSelection();
		event.trigger.textContent = 'Copied';
		window.setTimeout(function() {
			event.trigger.textContent = 'Copy';
		}, 2000);

	});

	// On error (Safari):
	// - Change the  "Press Ctrl+C to copy"
	// - Swap it to "Copy" in 2s.

	copyCode.on('error', function(event) {
		event.trigger.textContent = 'Press "Ctrl + C" to copy';
		window.setTimeout(function() {
			event.trigger.textContent = 'Copy';
		}, 5000);
	});

})();
</script>
