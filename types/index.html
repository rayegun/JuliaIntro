<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/JuliaIntro/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/JuliaIntro/css/franklin.css">
<link rel="stylesheet" href="/JuliaIntro/css/poole_hyde.css">
<link rel="stylesheet" href="/JuliaIntro/css/custom.css">
<link rel="stylesheet" href="/JuliaIntro/libs/highlight/styles/github-dark.min.css">

<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>

   <title>Types, What Are They Good For?</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1><a href="/JuliaIntro/">QNumerics</a></h1>
      <div class="logo-container">
        <img src="/JuliaIntro/assets/qnumerics-logo.png" alt="QNumerics Logo" class="logo-img">
      </div>
    </div>
    <nav class="sidebar-nav">
      
      <a class="sidebar-nav-item " href="/JuliaIntro/">Home</a>			  
      <ul class="menu-list-child-list ">
        <li class="menu-list-item"><a href="/JuliaIntro/#goals" class="menu-list-link">Goals</a>
        <li class="menu-list-item"><a href="/JuliaIntro/#contents" class="menu-list-link">Contents</a>
        <li class="menu-list-item"><a href="/JuliaIntro/#before_you_start" class="menu-list-link">Before you start</a>
      </ul>
      
      <a class="sidebar-nav-item " href="/JuliaIntro/startup/">Setting Up Environment</a>
        <ul class="menu-list-child-list ">
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#git" class="menu-list-link">Git</a>
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#vscode" class="menu-list-link">Visual Studio Code</a>
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#julia_+_vscode" class="menu-list-link">Julia + VSCode</a>
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#tips_tricks" class="menu-list-link">Tips & Tricks</a>
        </ul>
      <a class="sidebar-nav-item " href="/JuliaIntro/juliabasics/">First Steps</a>
        <ul class="menu-list-child-list ">
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#the_repl" class="menu-list-link">The REPL</a>
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#package_management" class="menu-list-link">Package Management</a>
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#basic_syntax" class="menu-list-link">Basic Syntax</a>
        </ul>
      <a class="sidebar-nav-item active" href="/JuliaIntro/types/">Types</a>
        <ul class="menu-list-child-list active">
          <li class="menu-list-item"><a href="/JuliaIntro/types/#the_repl" class="menu-list-link">The REPL</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#package_management" class="menu-list-link">Package Management</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#basic_syntax" class="menu-list-link">Basic Syntax</a>
        </ul>
      <a class="sidebar-nav-item " href="/JuliaIntro/types/">Multiple Dispatch</a>
        <ul class="menu-list-child-list ">
          <li class="menu-list-item"><a href="/JuliaIntro/dispatch/#the_repl" class="menu-list-link">The REPL</a>
          <li class="menu-list-item"><a href="/JuliaIntro/dispatch/#package_management" class="menu-list-link">Package Management</a>
          <li class="menu-list-item"><a href="/JuliaIntro/dispatch/#basic_syntax" class="menu-list-link">Basic Syntax</a>
        </ul>
    </nav>
    <p class="copyright-notice">
      <a href="https://github.com/modernjuliaworkflows/modernjuliaworkflows.github.io/blob/main/LICENSE">
        &copy; Raye Skye Kimmerer.
      </a>
    </p>
    <div class="github-link">
      <a href="https://github.com/modernjuliaworkflows/modernjuliaworkflows.github.io">
        <svg xmlns="http://www.w3.org/2000/svg" height="28px" fill="currentColor" viewBox="0 0 496 512">
          
          <path
            d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z" />
        </svg>
      </a>
    </div>
  </div>
</div>
<div class="content container">


<div class="franklin-content" >
  <h1 id="types,_what_are_they_good_for?" ><a href="#types,_what_are_they_good_for?"> Types, What Are They Good For?</a></h1><pre><code class="julia">using AbstractTrees</code></pre>
<h3 id="all_values_have_a_single_concrete_concrete_type_which_is_a_leaf_of_a_single_global_type_tree._all_types_are_"first_class"" ><a href="#all_values_have_a_single_concrete_concrete_type_which_is_a_leaf_of_a_single_global_type_tree._all_types_are_"first_class""> All values have a single concrete concrete type which is a leaf of a single global type tree. All types are "first-class"</a></h3><pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(3.14159265)
Float64

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(π)
Irrational{:π}

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(rand(3))
Vector{Float64}

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof([1, 1.5, true]) # What happened here?
Vector{Float64}

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(1.5 + 1//3 .- [1, 2, 3])
Vector{Float64}
</code></pre>
<p>Some languages such as Java have a distinction between certain primitive types like <code>Int64</code> and classes. While Julia does have primitive and non-primitive types:</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> isprimitivetype(Int64)
true

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> isprimitivetype(Vector{String})
false
</code></pre>
<p>The user experiences no difference, the distinction is purely for bootstrapping.</p>
<h3 id="variables_are_just_names,_and_are_untyped" ><a href="#variables_are_just_names,_and_are_untyped"> Variables are just names, and are untyped</a></h3><pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> x = 1.0
1.0

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(x)
Float64

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> x = [1,2,3]
[1, 2, 3]

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(x)
Vector{Int64}
</code></pre>
<h3 id="what_about_functions?" ><a href="#what_about_functions?"> What about functions?</a></h3><pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(sin)
typeof(sin)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof((x, y) -&gt; x + y^2) # Why does this look so weird?
Main.__FRANKLIN_1273372.var&quot;#1#2&quot;
</code></pre>
<h2 id="type_assertions" ><a href="#type_assertions"> Type assertions</a></h2><p>The most common place you will see types is constructors:</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> Int128(3)
3

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Vector{Float64}(undef, 2)
[6.92084285382906e-310, 6.92084285384724e-310]

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Complex{Float64}(1.0, 3.0)
1.0 + 3.0im
</code></pre>
<p>and in <em><strong>type assertions</em></strong>:</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> 3.0::Float64
3.0

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> 3.5::Int64
ERROR: TypeError: in typeassert, expected Int64, got a value of type Float64
Stacktrace:

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> (1.5 + 10)::Float64
11.5
</code></pre>
<div class="important"><p><strong>Important</strong> - <strong>This syntax is central to Julia programming</strong>
The type assertion syntax <code>::T</code> is used everywhere from struct definitions to Julia's all-important multiple-dispatch system which we will cover shortly. It is important to get comfortable with the meaning of this syntax</p>
</div><p>You can read <code>::Float64</code> as "is an instance of <code>Float64</code>". A type assertion ensures or states that the left hand side is a <em><strong>subtype</em></strong> of the right hand side. What does that mean?</p>
<h2 id="the_type_tree" ><a href="#the_type_tree"> The type tree</a></h2><p>You may know about type inheritance from a language like Java or C++, or even Python. In those languages you can create a type (classes in some languages), and then create a second type that inherits the fields and behavior of the parent.</p>
<p>Julia on the other has a tree of abstract types (which contain no structure), and what we call <em><strong>concrete</em></strong> types on the leaves:</p>
<pre><code class="julia">AbstractTrees.children(x::Type) = subtypes(x)

# All of the subtypes of the abstract type Number in a tree
print_tree(Number)</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">Number
├─ MultiplicativeInverse
│  ├─ SignedMultiplicativeInverse
│  └─ UnsignedMultiplicativeInverse
├─ Complex
├─ Formula
├─ Unit
│  ├─ DeviceIndependentPixel
│  ├─ Millimeter
│  ├─ Pixel
│  └─ SceneSpace
├─ Real
│  ├─ AbstractFloat
│  │  ├─ BigFloat
│  │  ├─ BFloat16
│  │  ├─ Float16
│  │  ├─ Float32
│  │  └─ Float64
│  ├─ AbstractIrrational
│  │  ├─ Irrational
│  │  └─ IrrationalConstant
│  │     ├─ Fourinvπ
│  │     ├─ Fourπ
│  │     ├─ Halfπ
│  │     ├─ Inv2π
│  │     ├─ Inv4π
│  │     ├─ Invsqrt2
│  │     ├─ Invsqrt2π
│  │     ├─ Invsqrtπ
│  │     ├─ Invπ
│  │     ├─ Log2π
│  │     ├─ Log4π
│  │     ├─ Loghalf
│  │     ├─ Logten
│  │     ├─ Logtwo
│  │     ├─ Logπ
│  │     ├─ Quartπ
│  │     ├─ Sqrt2
│  │     ├─ Sqrt2π
│  │     ├─ Sqrt3
│  │     ├─ Sqrt4π
│  │     ├─ Sqrthalfπ
│  │     ├─ Sqrtπ
│  │     ├─ Twoinvπ
│  │     └─ Twoπ
│  ├─ FixedPoint
│  │  ├─ Fixed
│  │  └─ Normed
│  ├─ Integer
│  │  ├─ Bool
│  │  ├─ OffsetInteger
│  │  ├─ Signed
│  │  │  ├─ BigInt
│  │  │  ├─ Int128
│  │  │  ├─ Int16
│  │  │  ├─ Int32
│  │  │  ├─ Int64
│  │  │  └─ Int8
│  │  └─ Unsigned
│  │     ├─ UInt128
│  │     ├─ UInt16
│  │     ├─ UInt32
│  │     ├─ UInt64
│  │     └─ UInt8
│  ├─ ExactReal
│  ├─ Interval
│  ├─ Rational
│  ├─ SimpleRatio
│  ├─ PValue
│  └─ TestStat
├─ AbstractQuantity
│  └─ Quantity
└─ LogScaled
   ├─ Gain{L} where L&lt;:LogInfo
   └─ Level{L} where L&lt;:LogInfo
</code></pre></div><p>Let's explore this type tree a little bit. At the top we have:</p>
<pre><code class="julia-repl"><span class="sgr33"><span class="sgr1">help?&gt;</span></span> Number
</code></pre>
<div class="repl-help">
<pre><code>Number</code></pre>
<p>Abstract supertype for all number types.</p>
</div>
<p>Since <code>Number</code> is not a leaf on our tree it is an <em><strong>abstract type</em></strong>. A fragment of this type tree would be defined as follows:</p>
<pre><code class="julia">abstract type Number end
abstract type Real          &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type Integer       &lt;: Real end
abstract type Signed        &lt;: Integer end
abstract type Unsigned      &lt;: Integer end</code></pre>
<p><code>abstract type</code> should be fairly self explanatory, but we have a new operator! The <code>&lt;:</code> subtype operator. <code>Number</code> has an implicit supertype here:</p>
<pre><code class="julia">supertype(Number)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">Any</code></pre></div><pre><code class="julia-repl"><span class="sgr33"><span class="sgr1">help?&gt;</span></span> Any
</code></pre>
<div class="repl-help">
<pre><code>Any::DataType</code></pre>
<p><code>Any</code> is the union of all types. It has the defining property <code>isa&#40;x, Any&#41; &#61;&#61; true</code> for any <code>x</code>. <code>Any</code> therefore describes the entire universe of possible values. For example <code>Integer</code> is a subset of <code>Any</code> that includes <code>Int</code>, <code>Int8</code>, and other integer types.</p>
</div>
<p>We have already seen <code>Any</code> many times without realizing it:</p>
<pre><code class="julia">foo(a, b) = 2a + 3b</code></pre>
<p>is equivalent to:</p>
<pre><code class="julia">foo(a::Any, b::Any) = 2a + 3b</code></pre>
<p>Immediately you should notice that we might specialize <code>foo</code> on some subtypes of <code>Any</code>. </p>
<h2 id="structs" ><a href="#structs"> Structs</a></h2><p>We've made do thus far with types defined by Julia, it's time we give it a shot!</p>
<p>One of the simplest types we might create is a <code>Point</code> consisting of two values <code>x</code> and <code>y</code>:</p>
<pre><code class="julia">struct Point1
    x
    y
end</code></pre>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> p = Point1(19, 97) # construct a Point1
Main.__FRANKLIN_1273372.Point1(19, 97)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p.x # access a field of p
19

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p2 = Point1(&quot;North&quot;, [1, 2, 3, 4])
Main.__FRANKLIN_1273372.Point1(&quot;North&quot;, [1, 2, 3, 4])

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p.y
97
</code></pre>
<h3 id="some_features_of_a_struct" ><a href="#some_features_of_a_struct"> Some features of a <code>struct</code></a></h3><ul>
<li>Types declared as <code>struct</code> are <em>immutable</em>:
  </li>
</ul>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> p.x = 2
ERROR: setfield!: immutable struct of type Point1 cannot be changed
Stacktrace:
  [1] setproperty!(x::Main.__FRANKLIN_1273372.Point1, f::Symbol, v::Int64)
    @ Base ./Base.jl:53

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p.y[1] = 10 # but not necessarily their fields
ERROR: MethodError: no method matching setindex!(::Int64, ::Int64, ::Int64)
The function `setindex!` exists, but no method is defined for this combination of argument types.
Stacktrace:

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p
Main.__FRANKLIN_1273372.Point1(19, 97)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> 
</code></pre>
<ul>
<li>Immutable structs are <em>identical</em> or *indistinguishable if their fields are indistinguishable:
  </li>
</ul>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point1(1, 2) === Point1(1, 2)
true

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> 
</code></pre>
  <pre><code class="julia-repl"><span class="sgr33"><span class="sgr1">help?&gt;</span></span> ===
</code></pre>
<div class="repl-help">
<pre><code>&#61;&#61;&#61;&#40;x,y&#41; -&gt; Bool
≡&#40;x,y&#41; -&gt; Bool</code></pre>
<p>Determine whether <code>x</code> and <code>y</code> are identical, in the sense that no program could distinguish them. First the types of <code>x</code> and <code>y</code> are compared. If those are identical, mutable objects are compared by address in memory and immutable objects &#40;such as numbers&#41; are compared by contents at the bit level. This function is sometimes called &quot;egal&quot;. It always returns a <code>Bool</code> value.</p>
<h1>Examples</h1>
<pre><code class="language-julia-repl">julia&gt; a &#61; &#91;1, 2&#93;; b &#61; &#91;1, 2&#93;;

julia&gt; a &#61;&#61; b
true

julia&gt; a &#61;&#61;&#61; b
false

julia&gt; a &#61;&#61;&#61; a
true</code></pre>
</div>
<ul>
<li>Because a copy is indistinguishable for an immutable struct, the compiler may optimize immutable values aggressively</li>
</ul>
<h3 id="why_might_point1_be_bad?" ><a href="#why_might_point1_be_bad?"> Why might <code>Point1</code> be bad?</a></h3><p>Implicitly the fields <code>x</code> and <code>y</code> are of type <code>Any</code>:</p>
<pre><code class="julia">struct Point1
    x::Any
    y::Any
end</code></pre>
<p>We can instead restrict the types of each field by either concrete or abstract types:</p>
<pre><code class="julia">struct Point2
    x::Float64
    y::Number
end</code></pre>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point2(1.5, 3)
Main.__FRANKLIN_1273372.Point2(1.5, 3)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point2([1,2,3], 4)
ERROR: MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Float64
The function `convert` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  convert(::Type{T}, !Matched::IntervalArithmetic.ExactReal) where T&lt;:Real
   @ IntervalArithmetic ~/.julia/packages/IntervalArithmetic/IbaUP/src/intervals/exact_literals.jl:120
  convert(::Type{T}, !Matched::Unitful.Quantity) where T&lt;:Real
   @ Unitful ~/.julia/packages/Unitful/GMTL8/src/conversion.jl:167
  convert(::Type{T}, !Matched::Unitful.Level) where T&lt;:Real
   @ Unitful ~/.julia/packages/Unitful/GMTL8/src/logarithm.jl:46
  ...

Stacktrace:
  [1] Main.__FRANKLIN_1273372.Point2(x::Vector{Int64}, y::Int64)
    @ Main.__FRANKLIN_1273372 ./string:2
</code></pre>
<h2 id="mutable_structs" ><a href="#mutable_structs"> Mutable structs</a></h2><p>Mutable types are created in a similar manner:</p>
<pre><code class="julia">mutable sturct Point3
    x::Float64
    y::ComplexF64
end</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">ERROR: UndefVarError: `mutable` not defined in `Main.__FRANKLIN_1273372`
Suggestion: check for spelling errors or missing imports.
Stacktrace:
</code></pre></div><p>But they differ in two ways:</p>
<ol>
<li>We can mutate their fields:
   </li>
</ol>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> p = Point3(1.0, 10 + 1im)
ERROR: UndefVarError: `Point3` not defined in `Main.__FRANKLIN_1273372`
Suggestion: check for spelling errors or missing imports.
Hint: a global variable of this name may be made accessible by importing GeometryBasics in the current active module Main
Hint: a global variable of this name may be made accessible by importing Makie in the current active module Main
Hint: a global variable of this name may be made accessible by importing CairoMakie in the current active module Main
Stacktrace:

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p.x = 10
ERROR: setfield!: immutable struct of type Point1 cannot be changed
Stacktrace:
  [1] setproperty!(x::Main.__FRANKLIN_1273372.Point1, f::Symbol, v::Int64)
    @ Base ./Base.jl:53

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p
Main.__FRANKLIN_1273372.Point1(19, 97)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p2 = copy(p)
ERROR: MethodError: no method matching copy(::Main.__FRANKLIN_1273372.Point1)
The function `copy` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  copy(!Matched::DelaunayTriangulation.BoundingInterval)
   @ DelaunayTriangulation ~/.julia/packages/DelaunayTriangulation/P5U9H/src/data_structures/trees/rtree.jl:48
  copy(!Matched::StableRNGs.LehmerRNG)
   @ StableRNGs ~/.julia/packages/StableRNGs/t609C/src/StableRNGs.jl:64
  copy(!Matched::DelaunayTriangulation.LineSegment)
   @ DelaunayTriangulation ~/.julia/packages/DelaunayTriangulation/P5U9H/src/data_structures/mesh_refinement/curves/linesegment.jl:24
  ...

Stacktrace:

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p == p2
false

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p === p2
false

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> 
</code></pre>
<ol start="2">
<li>Since the value named <code>p</code> can change over time it can only be identified by it's address in memory. Hence types declared as <code>mutable struct</code> are typically stored with a stable address in memory.</li>
</ol>

  <div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Raye Skye Kimmerer. Last modified: July 14, 2025. </br>
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>

</div>

    </div>  
    
    
        <script src="/JuliaIntro/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
