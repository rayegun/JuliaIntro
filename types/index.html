<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/JuliaIntro/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/JuliaIntro/css/franklin.css">
<link rel="stylesheet" href="/JuliaIntro/css/poole_hyde.css">
<link rel="stylesheet" href="/JuliaIntro/css/custom.css">
<link rel="stylesheet" href="/JuliaIntro/libs/highlight/styles/github-dark.min.css">

<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>

   <title>Types, What Are They Good For?</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1><a href="/JuliaIntro/">QNumerics</a></h1>
      <div class="logo-container">
        <img src="/JuliaIntro/assets/qnumerics-logo.png" alt="QNumerics Logo" class="logo-img">
      </div>
    </div>
    <nav class="sidebar-nav">
      
      <a class="sidebar-nav-item " href="/JuliaIntro/">Home</a>			  
      <ul class="menu-list-child-list ">
        <li class="menu-list-item"><a href="/JuliaIntro/#goals" class="menu-list-link">Goals</a>
        <li class="menu-list-item"><a href="/JuliaIntro/#contents" class="menu-list-link">Contents</a>
        <li class="menu-list-item"><a href="/JuliaIntro/#before_you_start" class="menu-list-link">Before you start</a>
      </ul>
      
      <a class="sidebar-nav-item " href="/JuliaIntro/startup/">Setting Up Environment</a>
        <ul class="menu-list-child-list ">
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#git" class="menu-list-link">Git</a>
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#vscode" class="menu-list-link">Visual Studio Code</a>
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#julia_+_vscode" class="menu-list-link">Julia + VSCode</a>
          <li class="menu-list-item"><a href="/JuliaIntro/writing/#tips_tricks" class="menu-list-link">Tips & Tricks</a>
        </ul>
      <a class="sidebar-nav-item " href="/JuliaIntro/juliabasics/">First Steps</a>
        <ul class="menu-list-child-list ">
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#the_repl" class="menu-list-link">The REPL</a>
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#environments" class="menu-list-link">Environments</a>
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#package_management" class="menu-list-link">Package Management</a>
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#basic_syntax" class="menu-list-link">Basic Syntax</a>
          <li class="menu-list-item"><a href="/JuliaIntro/juliabasics/#arrays!" class="menu-list-link">Arrays!</a>
        </ul>
      <a class="sidebar-nav-item active" href="/JuliaIntro/types/">Types</a>
        <ul class="menu-list-child-list active">
          <li class="menu-list-item"><a href="/JuliaIntro/types/#the_type_tree" class="menu-list-link">Type Trees</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#structs" class="menu-list-link">Structs</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#mutable_structs" class="menu-list-link">Mutable Structs</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#parametric_types" class="menu-list-link">Parametric Types</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#tuples" class="menu-list-link">Tuples</a>
          <li class="menu-list-item"><a href="/JuliaIntro/types/#advanced_topics" class="menu-list-link">Advanced Topics</a>
        </ul>
      <a class="sidebar-nav-item " href="/JuliaIntro/dispatch/">Multiple Dispatch</a>
        <ul class="menu-list-child-list ">
          <li class="menu-list-item"><a href="/JuliaIntro/dispatch/#the_repl" class="menu-list-link">The REPL</a>
          <li class="menu-list-item"><a href="/JuliaIntro/dispatch/#package_management" class="menu-list-link">Package Management</a>
          <li class="menu-list-item"><a href="/JuliaIntro/dispatch/#basic_syntax" class="menu-list-link">Basic Syntax</a>
        </ul>
    </nav>
    <p class="copyright-notice">
      <a href="https://github.com/modernjuliaworkflows/modernjuliaworkflows.github.io/blob/main/LICENSE">
        &copy; Raye Skye Kimmerer.
      </a>
    </p>
    <div class="github-link">
      <a href="https://github.com/modernjuliaworkflows/modernjuliaworkflows.github.io">
        <svg xmlns="http://www.w3.org/2000/svg" height="28px" fill="currentColor" viewBox="0 0 496 512">
          
          <path
            d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z" />
        </svg>
      </a>
    </div>
  </div>
</div>
<div class="content container">


<script src="/JuliaIntro/libs/clipboard.min.js"></script>
<div class="franklin-content" >
  <h1 id="types,_what_are_they_good_for?" ><a href="#types,_what_are_they_good_for?"> Types, What Are They Good For?</a></h1><div class="toc"><ol><li><a href="#type_assertions">Type assertions</a></li><li><a href="#the_type_tree">The Type Tree</a></li><li><a href="#structs">Structs</a></li><li><a href="#mutable_structs">Mutable structs</a></li><li><a href="#when_should_you_use_a_struct_or_a_mutable_struct?">When should you use a <code>struct</code> or a <code>mutable struct</code>?</a></li><li><a href="#parametric_types">Parametric Types</a></li><li><a href="#what's_the_type_of_a_type?">What's the type of a type?</a></li><li><a href="#tuples">Tuples</a></li><li><a href="#unions">Unions</a></li><li><a href="#unionalls">UnionAlls</a></li></ol></div><pre><code class="julia">using AbstractTrees</code></pre>
<h3 id="all_values_have_a_single_concrete_concrete_type_which_is_a_leaf_of_a_single_global_type_tree._all_types_are_"first_class"" ><a href="#all_values_have_a_single_concrete_concrete_type_which_is_a_leaf_of_a_single_global_type_tree._all_types_are_"first_class""> All values have a single concrete concrete type which is a leaf of a single global type tree. All types are "first-class"</a></h3><pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(3.14159265)
Float64

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(π)
Irrational{:π}

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(rand(3))
Vector{Float64}

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof([1, 1.5, true]) # What happened here?
Vector{Float64}

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(1.5 + 1//3 .- [1, 2, 3])
Vector{Float64}
</code></pre>
<p>Some languages such as Java have a distinction between certain primitive types like <code>Int64</code> and classes. While Julia does have primitive and non-primitive types:</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> isprimitivetype(Int64)
true

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> isprimitivetype(Vector{String})
false
</code></pre>
<p>The user experiences no difference, the distinction is purely for bootstrapping.</p>
<h3 id="variables_are_just_names,_and_are_untyped" ><a href="#variables_are_just_names,_and_are_untyped"> Variables are just names, and are untyped</a></h3><pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> x = 1.0
1.0

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(x)
Float64

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> x = [1,2,3]
[1, 2, 3]

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(x)
Vector{Int64}
</code></pre>
<h3 id="what_about_functions?" ><a href="#what_about_functions?"> What about functions?</a></h3><pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(sin)
typeof(sin)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof((x, y) -&gt; x + y^2) # Why does this look so weird?
Main.__FRANKLIN_1273372.var&quot;#1#2&quot;
</code></pre>
<h2 id="type_assertions" ><a href="#type_assertions"> Type assertions</a></h2><p>The most common place you will see types is constructors:</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> Int128(3)
3

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Vector{Float64}(undef, 2)
[6.95132757367213e-310, 6.95133514623605e-310]

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Complex{Float64}(1.0, 3.0)
1.0 + 3.0im
</code></pre>
<p>and in <em><strong>type assertions</em></strong>:</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> 3.0::Float64
3.0

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> 3.5::Int64
ERROR: TypeError: in typeassert, expected Int64, got a value of type Float64
Stacktrace:

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> (1.5 + 10)::Float64
11.5
</code></pre>
<div class="important"><p><strong>Important</strong> - <strong>This syntax is central to Julia programming</strong>
The type assertion syntax <code>::T</code> is used everywhere from struct definitions to Julia's all-important multiple-dispatch system which we will cover shortly. It is important to get comfortable with the meaning of this syntax</p>
</div><p>You can read <code>::Float64</code> as "is an instance of <code>Float64</code>". A type assertion ensures or states that the left hand side is a <em><strong>subtype</em></strong> of the right hand side. What does that mean?</p>
<h2 id="the_type_tree" ><a href="#the_type_tree"> The Type Tree</a></h2><p>You may know about type inheritance from a language like Java or C++, or even Python. In those languages you can create a type (classes in some languages), and then create a second type that inherits the fields and behavior of the parent.</p>
<p>Julia on the other has a tree of abstract types (which contain no structure), and what we call <em><strong>concrete</em></strong> types on the leaves:</p>
<pre><code class="julia">AbstractTrees.children(x::Type) = subtypes(x)

# All of the subtypes of the abstract type Number in a tree
print_tree(Number)</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">Number
├─ MultiplicativeInverse
│  ├─ SignedMultiplicativeInverse
│  └─ UnsignedMultiplicativeInverse
├─ Complex
└─ Real
   ├─ AbstractFloat
   │  ├─ BigFloat
   │  ├─ BFloat16
   │  ├─ Float16
   │  ├─ Float32
   │  └─ Float64
   ├─ AbstractIrrational
   │  └─ Irrational
   ├─ Integer
   │  ├─ Bool
   │  ├─ Signed
   │  │  ├─ BigInt
   │  │  ├─ Int128
   │  │  ├─ Int16
   │  │  ├─ Int32
   │  │  ├─ Int64
   │  │  └─ Int8
   │  └─ Unsigned
   │     ├─ UInt128
   │     ├─ UInt16
   │     ├─ UInt32
   │     ├─ UInt64
   │     └─ UInt8
   └─ Rational
</code></pre></div><p>Let's explore this type tree a little bit. At the top we have:</p>
<pre><code class="julia-repl"><span class="sgr33"><span class="sgr1">help?&gt;</span></span> Number
</code></pre>
<div class="repl-help">
<pre><code>Number</code></pre>
<p>Abstract supertype for all number types.</p>
</div>
<p>Since <code>Number</code> is not a leaf on our tree it is an <em><strong>abstract type</em></strong>. A fragment of this type tree would be defined as follows:</p>
<pre><code class="julia">abstract type Number end
abstract type Real          &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type Integer       &lt;: Real end
abstract type Signed        &lt;: Integer end
abstract type Unsigned      &lt;: Integer end</code></pre>
<p><code>abstract type</code> should be fairly self explanatory, but we have a new operator! The <code>&lt;:</code> subtype operator. <code>Number</code> has an implicit supertype here:</p>
<pre><code class="julia">supertype(Number)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">Any</code></pre></div><pre><code class="julia-repl"><span class="sgr33"><span class="sgr1">help?&gt;</span></span> Any
</code></pre>
<div class="repl-help">
<pre><code>Any::DataType</code></pre>
<p><code>Any</code> is the union of all types. It has the defining property <code>isa&#40;x, Any&#41; &#61;&#61; true</code> for any <code>x</code>. <code>Any</code> therefore describes the entire universe of possible values. For example <code>Integer</code> is a subset of <code>Any</code> that includes <code>Int</code>, <code>Int8</code>, and other integer types.</p>
</div>
<p>We have already seen <code>Any</code> many times without realizing it:</p>
<pre><code class="julia">foo(a, b) = 2a + 3b</code></pre>
<p>is equivalent to:</p>
<pre><code class="julia">foo(a::Any, b::Any) = 2a + 3b</code></pre>
<p>Immediately you should notice that we might specialize <code>foo</code> on some subtypes of <code>Any</code>. </p>
<h2 id="structs" ><a href="#structs"> Structs</a></h2><p>We've made do thus far with types defined by Julia, it's time we give it a shot!</p>
<p>One of the simplest types we might create is a <code>Point</code> consisting of two values <code>x</code> and <code>y</code>:</p>
<pre><code class="julia">struct Point1
    x
    y
end</code></pre>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> p = Point1(19, 97) # construct a Point1
Main.__FRANKLIN_1273372.Point1(19, 97)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p.x # access a field of p
19

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p2 = Point1(&quot;North&quot;, [1, 2, 3, 4])
Main.__FRANKLIN_1273372.Point1(&quot;North&quot;, [1, 2, 3, 4])

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p.y
97
</code></pre>
<h3 id="some_features_of_a_struct" ><a href="#some_features_of_a_struct"> Some features of a <code>struct</code></a></h3><ul>
<li>Types declared as <code>struct</code> are <em>immutable</em>:
  </li>
</ul>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> p.x = 2
ERROR: setfield!: immutable struct of type Point1 cannot be changed
Stacktrace:
  [1] setproperty!(x::Main.__FRANKLIN_1273372.Point1, f::Symbol, v::Int64)
    @ Base ./Base.jl:53

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p.y[1] = 10 # but not necessarily their fields
ERROR: MethodError: no method matching setindex!(::Int64, ::Int64, ::Int64)
The function `setindex!` exists, but no method is defined for this combination of argument types.
Stacktrace:

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p
Main.__FRANKLIN_1273372.Point1(19, 97)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> 
</code></pre>
<ul>
<li>Immutable structs are <em>identical</em> or *indistinguishable if their fields are indistinguishable:
  </li>
</ul>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point1(1, 2) === Point1(1, 2)
true

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> 
</code></pre>
  <pre><code class="julia-repl"><span class="sgr33"><span class="sgr1">help?&gt;</span></span> ===
</code></pre>
<div class="repl-help">
<pre><code>&#61;&#61;&#61;&#40;x,y&#41; -&gt; Bool
≡&#40;x,y&#41; -&gt; Bool</code></pre>
<p>Determine whether <code>x</code> and <code>y</code> are identical, in the sense that no program could distinguish them. First the types of <code>x</code> and <code>y</code> are compared. If those are identical, mutable objects are compared by address in memory and immutable objects &#40;such as numbers&#41; are compared by contents at the bit level. This function is sometimes called &quot;egal&quot;. It always returns a <code>Bool</code> value.</p>
<h1>Examples</h1>
<pre><code class="language-julia-repl">julia&gt; a &#61; &#91;1, 2&#93;; b &#61; &#91;1, 2&#93;;

julia&gt; a &#61;&#61; b
true

julia&gt; a &#61;&#61;&#61; b
false

julia&gt; a &#61;&#61;&#61; a
true</code></pre>
</div>
<ul>
<li>Because a copy is indistinguishable for an immutable struct, the compiler may optimize immutable values aggressively</li>
</ul>
<h3 id="why_might_point1_be_bad?" ><a href="#why_might_point1_be_bad?"> Why might <code>Point1</code> be bad?</a></h3><p>Implicitly the fields <code>x</code> and <code>y</code> are of type <code>Any</code>:</p>
<pre><code class="julia">struct Point1
    x::Any
    y::Any
end</code></pre>
<div class="important"><p><strong>Important</strong> - <strong><code>p.x</code> and <code>p.y</code> retained their type</strong>
despite the fact that the fields of <code>Point1</code> are <code>Any</code>. This is a fundamental feature of the language, that values never change type. <em>However</em> we will see that since the compiler will have trouble <em>predicting</em> the value of those fields ahead of time it must be pessimistic</p>
</div><p>We can instead restrict the types of each field by either concrete or abstract types:</p>
<pre><code class="julia">struct Point2
    x::Float64
    y::Number
end</code></pre>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point2(1.5, 3)
Main.__FRANKLIN_1273372.Point2(1.5, 3)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point2([1,2,3], 4)
ERROR: MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Float64
The function `convert` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  convert(::Type{T}, !Matched::T) where T&lt;:Number
   @ Base number.jl:6
  convert(::Type{T}, !Matched::Number) where T&lt;:Number
   @ Base number.jl:7
  convert(::Type{T}, !Matched::T) where T
   @ Base Base.jl:126
  ...

Stacktrace:
  [1] Main.__FRANKLIN_1273372.Point2(x::Vector{Int64}, y::Int64)
    @ Main.__FRANKLIN_1273372 ./string:2
</code></pre>
<h2 id="mutable_structs" ><a href="#mutable_structs"> Mutable structs</a></h2><p>Mutable types are created in a similar manner:</p>
<pre><code class="julia">mutable struct Point3 &lt;: Any
    x::Float64
    y::ComplexF64
end</code></pre>
<p>But they differ in two ways:</p>
<ol>
<li>We can mutate their fields:
   </li>
</ol>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> p = Point3(1.0, 10 + 1im)
Main.__FRANKLIN_1273372.Point3(1.0, 10.0 + 1.0im)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p.x = 10
10

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p
Main.__FRANKLIN_1273372.Point3(10.0, 10.0 + 1.0im)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p2 = Point3(10, 10 + 1im)
Main.__FRANKLIN_1273372.Point3(10.0, 10.0 + 1.0im)

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p == p2 # we can write a new method for == to make this true
false

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> p === p2 # we cannot make this true
false

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> 
</code></pre>
<ol start="2">
<li>Since the value named <code>p</code> can change over time it can only be identified by it's address in memory. Hence types declared as <code>mutable struct</code> are typically stored with a stable address in memory.</li>
</ol>
<h2 id="when_should_you_use_a_struct_or_a_mutable_struct?" ><a href="#when_should_you_use_a_struct_or_a_mutable_struct?"> When should you use a <code>struct</code> or a <code>mutable struct</code>?</a></h2><ul>
<li>You might pick a <code>struct</code> if:<ul>
<li>The data in your struct will never change</li>
<li>A copy of your struct is identifiable solely by its contents:<ul>
<li>A number, or a point in space, is solely identified by its contents</li>
<li>Two cars fresh off the lot may appear exactly identical, but are not indistinguishable</li>
</ul>
</li>
<li>You have thousands or millions of these structs stored in collections like <code>Vector</code>s</li>
</ul>
</li>
<li>You might pick a <code>mutable struct</code> if:<ul>
<li>The contents are constantly changing</li>
<li>The value is large</li>
<li>The struct has identity unrelated to its contents</li>
</ul>
</li>
</ul>
<h2 id="parametric_types" ><a href="#parametric_types"> Parametric Types</a></h2><p>Our first <code>Point</code> struct had fields which could contain any value. That freedom is great, and Julia happily accepts this level of dynamism. But we have another often better solution with <em><strong>parametrization</em></strong>.</p>
<p>We have already seen parametric types before:</p>
<pre><code class="julia">mutable struct Vector&lbrace;T&rbrace; &lt;: DenseVector&lbrace;T&rbrace;
    ref::MemoryRef&lbrace;T&rbrace;
    size::Tuple&lbrace;Int64&rbrace;
end
mutable struct Matrix&lbrace;T&rbrace; &lt;: DenseMatrix&lbrace;T&rbrace;
    ref::MemoryRef&lbrace;T&rbrace;
    size::Tuple&lbrace;Int64, Int64&rbrace;
end
mutable struct Array&lbrace;T, N&rbrace; &lt;: DenseArray&lbrace;T, N&rbrace;
    ref::MemoryRef&lbrace;T&rbrace;
    size::NTuple&lbrace;N, Int64&rbrace;
end</code></pre>
<p>Let's take a look at the type tree they are part of:</p>
<pre><code class="julia">print_tree(AbstractArray)</code></pre>
<div class="code-output"><pre><code class="code-stdout language-plaintext">AbstractArray
├─ AbstractRange
│  ├─ LinRange
│  ├─ OrdinalRange
│  │  ├─ AbstractUnitRange
│  │  │  ├─ IdentityUnitRange
│  │  │  ├─ OneTo
│  │  │  ├─ Slice
│  │  │  └─ UnitRange
│  │  └─ StepRange
│  └─ StepRangeLen
├─ AbstractSlices
│  └─ Slices
├─ ExceptionStack
├─ LogRange
├─ LogicalIndex
├─ MethodList
├─ ReinterpretArray
├─ ReshapedArray
├─ SCartesianIndices2
├─ WithoutMissingVector
├─ BitArray
├─ CartesianIndices
├─ AbstractRange
│  ├─ LinRange
│  ├─ OrdinalRange
│  │  ├─ AbstractUnitRange
│  │  │  ├─ IdentityUnitRange
│  │  │  ├─ OneTo
│  │  │  ├─ Slice
│  │  │  ├─ StmtRange
│  │  │  └─ UnitRange
│  │  └─ StepRange
│  └─ StepRangeLen
├─ BitArray
├─ ExceptionStack
├─ LinearIndices
├─ LogRange
├─ MethodList
├─ TwoPhaseDefUseMap
├─ TwoPhaseVectorView
├─ DenseArray
│  ├─ Array
│  ├─ CodeUnits
│  ├─ Const
│  ├─ GenericMemory
│  └─ UnsafeView
├─ AbstractTriangular
│  ├─ LowerTriangular
│  ├─ UnitLowerTriangular
│  ├─ UnitUpperTriangular
│  └─ UpperTriangular
├─ Adjoint
├─ Bidiagonal
├─ Diagonal
├─ Hermitian
├─ SymTridiagonal
├─ Symmetric
├─ Transpose
├─ Tridiagonal
├─ UpperHessenberg
├─ LinearIndices
├─ PermutedDimsArray
├─ SubArray
└─ GenericArray
</code></pre></div><p>The type tree for <code>AbstractArray</code> is massive, and that's with very few additional packages loaded which may add new subtypes. But it's deceptively small. We know that at least three of the types in this tree are parametric, and each one of those contains a potentially infinite subtree of subtypes.</p>
<p>So let's make our own infinite tree of subtypes:</p>
<pre><code class="julia">struct Point&lbrace;T&rbrace;
    x::T
    y::T
end</code></pre>
<p>Play around with substituting various types, and let's examine the subtyping relationships which are a little bit subtle!</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point{Complex{Float64}}
Main.__FRANKLIN_1273372.Point{ComplexF64}

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point{AbstractArray}
Main.__FRANKLIN_1273372.Point{AbstractArray}

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point{Complex{Float64}} &lt;: Point
true

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point{AbstractArray} &lt;: Point
true

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(rand(10, 10)) &lt;: Point
false

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> # is equivalent to:

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> rand(10, 10) isa Point
false

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> isconcretetype(Point)
false

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> isconcretetype(Point{AbstractArray})
true
</code></pre>
<p>What will happen when I run this code?</p>
<pre><code class="julia">Point&lbrace;Float16&rbrace; &lt;: Point&lbrace;BigInt&rbrace;

Float64 &lt;: Real

Point&lbrace;Float16&rbrace; &lt;: Point&lbrace;Real&rbrace;</code></pre>
<div class="important">
<hr>
<p>A <code>Point&lbrace;Float16&rbrace;</code> has a different representation from a <code>Point&lbrace;Real&rbrace;</code> in memory which at a low level must contain two pointers to arbitrary subtypes of <code>Real</code> while <code>Point&lbrace;Float16&rbrace;</code> is just <code>4</code>-bytes</p>
</div><p>We can overcome this limitation if needed using the subtype operator <code>&lt;:</code> again:</p>
<pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> Point{Float16} &lt;: Point{&lt;:Real}
true
</code></pre>
<h3 id="abstract_types_can_be_parametric_as_well,_with_similar_rules" ><a href="#abstract_types_can_be_parametric_as_well,_with_similar_rules"> Abstract types can be parametric as well, with similar rules:</a></h3><pre><code class="julia-repl"><span class="sgr33"><span class="sgr1">help?&gt;</span></span> AbstractArray
</code></pre>
<div class="repl-help">
<pre><code>AbstractArray&#123;T,N&#125;</code></pre>
<p>Supertype for <code>N</code>-dimensional arrays &#40;or array-like types&#41; with elements of type <code>T</code>.  and other types are subtypes of this. See the manual section on the  man-interface-array.</p>
<p>See also: , , , .</p>
</div>
<h2 id="what's_the_type_of_a_type?" ><a href="#what's_the_type_of_a_type?"> What's the type of a type?</a></h2><pre><code class="julia-repl"><span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(Int64)
DataType

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(Vector) # 🤔
UnionAll

<span class="sgr32"><span class="sgr1">julia&gt;</span></span> typeof(Vector{Float64})
DataType
</code></pre>
<p>The first and last examples right above were concrete types. But the middle one is a parametric type with no parameter! </p>
<h2 id="tuples" ><a href="#tuples"> Tuples</a></h2><p>When you think of a <code>Tuple</code> type you should think of it as analogous to the arguments of a function:</p>
<pre><code class="julia">function foo(a, b, c)
    [a, b, c]' .^ 2 * [a, b, c]
end</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">foo (generic function with 1 method)</code></pre></div><h1 id="advanced_topics" ><a href="#advanced_topics"> Advanced Topics </a></h1><h2 id="unions" ><a href="#unions"> Unions</a></h2><h2 id="unionalls" ><a href="#unionalls"> UnionAlls</a></h2>
  <div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Raye Skye Kimmerer. Last modified: July 14, 2025. </br>
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>

</div>

    </div>  
    
    
        <script src="/JuliaIntro/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>


<script>
(function(){

	// Get the elements.
	// - the 'pre' element.
	// - the 'div' with the 'paste-content' id.

	var pre = document.getElementsByTagName('pre');

	// Add a copy button in the 'pre' element.
	// which only has the className of 'language-' or ' hljs'(if enable highlight.js pre-render).

	for (var i = 0; i < pre.length; i++) {
		var tag_name = pre[i].children[0].className
            	var isLanguage = tag_name.startsWith('language-') || tag_name.endsWith(' hljs');
		if ( isLanguage ) {
			var button           = document.createElement('button');
					button.className = 'copy-button';
					button.textContent = 'Copy';

					pre[i].appendChild(button);
		}
	};

	// Run Clipboard

	var copyCode = new Clipboard('.copy-button', {
		target: function(trigger) {
			return trigger.previousElementSibling;
    }
	});

	// On success:
	// - Change the "Copy" text to "Copied".
	// - Swap it to "Copy" in 2s.
	// - Lead user to the "contenteditable" area with Velocity scroll.

	copyCode.on('success', function(event) {
		event.clearSelection();
		event.trigger.textContent = 'Copied';
		window.setTimeout(function() {
			event.trigger.textContent = 'Copy';
		}, 2000);

	});

	// On error (Safari):
	// - Change the  "Press Ctrl+C to copy"
	// - Swap it to "Copy" in 2s.

	copyCode.on('error', function(event) {
		event.trigger.textContent = 'Press "Ctrl + C" to copy';
		window.setTimeout(function() {
			event.trigger.textContent = 'Copy';
		}, 5000);
	});

})();
</script>
